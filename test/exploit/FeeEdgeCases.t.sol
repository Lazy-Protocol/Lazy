// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console2} from "forge-std/Test.sol";
import {USDCSavingsVault} from "../../src/USDCSavingsVault.sol";
import {VaultShare} from "../../src/VaultShare.sol";
import {StrategyOracle} from "../../src/StrategyOracle.sol";
import {RoleManager} from "../../src/RoleManager.sol";
import {MockUSDC} from "../mocks/MockUSDC.sol";

/**
 * @title FeeEdgeCases
 * @notice Tests for fee calculation edge cases and potential exploits
 * @dev Analyzes:
 *      1. Fee calculation at extreme yields
 *      2. HWM manipulation
 *      3. Fee bypass attempts
 *      4. Division by zero scenarios
 */
contract FeeEdgeCases is Test {
    USDCSavingsVault public vault;
    VaultShare public shares;
    StrategyOracle public strategyOracle;
    RoleManager public roleManager;
    MockUSDC public usdc;

    address public owner = address(this);
    address public multisig = makeAddr("multisig");
    address public treasury = makeAddr("treasury");
    address public operator = makeAddr("operator");

    address public attacker = makeAddr("attacker");

    function setUp() public {
        usdc = new MockUSDC();
        roleManager = new RoleManager(owner);
        strategyOracle = new StrategyOracle(address(roleManager));

        vault = new USDCSavingsVault(
            address(usdc),
            address(strategyOracle),
            address(roleManager),
            multisig,
            treasury,
            0.2e18, // 20% fee
            1 days,
            "USDC Savings Vault Share",
            "svUSDC"
        );
        shares = vault.shares();
        roleManager.setOperator(operator, true);
        strategyOracle.setVault(address(vault));
        strategyOracle.setMaxYieldChangePercent(0);
        vault.setWithdrawalBuffer(type(uint256).max);

        usdc.mint(attacker, 100_000_000e6);
        vm.prank(attacker);
        usdc.approve(address(vault), type(uint256).max);
    }

    /**
     * @notice Test: Fee at extreme yield (>100%)
     * @dev FINDING: HANDLED - C-1 guard prevents fee >= NAV
     */
    function test_ANALYSIS_FeeAtExtremeYield() public {
        console2.log("=== FEE AT EXTREME YIELD ===");
        console2.log("");

        vm.prank(attacker);
        vault.deposit(1_000_000e6);

        uint256 hwmBefore = vault.priceHighWaterMark();
        console2.log("HWM before:", hwmBefore);

        // Extreme yield: 500%
        vm.warp(block.timestamp + 1 days);
        strategyOracle.reportYield(5_000_000e6);

        uint256 priceAfter = vault.sharePrice();
        console2.log("Price after 500% yield:", priceAfter);

        // Collect fees
        vault.collectFees();

        uint256 treasuryShares = shares.balanceOf(treasury);
        console2.log("Treasury received shares:", treasuryShares);

        uint256 hwmAfter = vault.priceHighWaterMark();
        console2.log("HWM after:", hwmAfter);

        console2.log("");
        console2.log("RESULT: Fee collection handled correctly at extreme yield");
    }

    /**
     * @notice Test: Fee when NAV approaches fee amount
     * @dev FINDING: PROTECTED - Guard skips fee if fee >= NAV
     */
    function test_ANALYSIS_FeeEqualsNAV() public {
        console2.log("=== FEE EQUALS NAV EDGE CASE ===");
        console2.log("");

        vm.prank(attacker);
        vault.deposit(100e6); // Small deposit

        // Yield that would create fee >= NAV
        vm.warp(block.timestamp + 1 days);
        strategyOracle.reportYield(1000e6); // 1000% yield

        uint256 nav = vault.totalAssets();
        console2.log("NAV:", nav);

        // This should not revert due to C-1 guard
        vault.collectFees();

        console2.log("Fee collection completed without revert");
        console2.log("");
        console2.log("RESULT: C-1 guard prevents division by zero");
    }

    /**
     * @notice Test: HWM reset attack
     * @dev FINDING: CENTRALIZATION RISK - Owner can skip fees via resetPriceHWM
     */
    function test_ANALYSIS_HWMResetAttack() public {
        console2.log("=== HWM RESET ATTACK (OWNER RISK) ===");
        console2.log("");

        vm.prank(attacker);
        vault.deposit(1_000_000e6);

        // Report yield
        vm.warp(block.timestamp + 1 days);
        strategyOracle.reportYield(100_000e6);

        uint256 hwmBefore = vault.priceHighWaterMark();
        uint256 currentPrice = vault.sharePrice();
        console2.log("HWM before:", hwmBefore);
        console2.log("Current price:", currentPrice);

        // Owner resets HWM to current price (skips fees)
        vault.resetPriceHWM();

        uint256 hwmAfter = vault.priceHighWaterMark();
        console2.log("HWM after reset:", hwmAfter);

        // Now collect fees - should collect nothing
        uint256 treasuryBefore = shares.balanceOf(treasury);
        vault.collectFees();
        uint256 treasuryAfter = shares.balanceOf(treasury);

        console2.log("Treasury before:", treasuryBefore);
        console2.log("Treasury after:", treasuryAfter);
        assertEq(treasuryBefore, treasuryAfter, "No fees should be collected after HWM reset");

        console2.log("");
        console2.log("RESULT: Owner can skip fees via resetPriceHWM");
        console2.log("This is documented behavior (emergency function)");
    }

    /**
     * @notice Test: Negative yield resets opportunity for future fees
     * @dev FINDING: EXPECTED BEHAVIOR - Negative yield doesn't affect HWM
     */
    function test_ANALYSIS_NegativeYieldHWM() public {
        console2.log("=== NEGATIVE YIELD HWM BEHAVIOR ===");
        console2.log("");

        vm.prank(attacker);
        vault.deposit(1_000_000e6);

        // Report positive yield
        vm.warp(block.timestamp + 1 days);
        strategyOracle.reportYield(100_000e6);
        vault.collectFees();

        uint256 hwmAfterGain = vault.priceHighWaterMark();
        console2.log("HWM after gain:", hwmAfterGain);

        // Report negative yield
        vm.warp(block.timestamp + 1 days);
        strategyOracle.reportYield(-50_000e6);

        uint256 priceAfterLoss = vault.sharePrice();
        uint256 hwmAfterLoss = vault.priceHighWaterMark();
        console2.log("Price after loss:", priceAfterLoss);
        console2.log("HWM after loss:", hwmAfterLoss);

        // HWM should NOT decrease (it's a high water mark)
        assertEq(hwmAfterLoss, hwmAfterGain, "HWM should not decrease on loss");

        console2.log("");
        console2.log("RESULT: HWM correctly maintains high water mark");
    }

    /**
     * @notice Test: Fee bypass via withdrawal timing
     * @dev FINDING: NOT POSSIBLE - Fees collected before withdrawal processing
     */
    function test_ANALYSIS_FeeBypassViaWithdrawal() public {
        console2.log("=== FEE BYPASS VIA WITHDRAWAL ===");
        console2.log("");

        vm.prank(attacker);
        uint256 attackerShares = vault.deposit(1_000_000e6);

        // Report yield
        vm.warp(block.timestamp + 1 days);
        strategyOracle.reportYield(100_000e6);

        // Try to withdraw before fees are collected
        vm.prank(attacker);
        vault.requestWithdrawal(attackerShares);

        vm.warp(block.timestamp + 1 days);

        // Fulfill triggers fee collection FIRST
        vm.prank(operator);
        vault.fulfillWithdrawals(1);

        uint256 treasuryShares = shares.balanceOf(treasury);
        console2.log("Treasury shares after withdrawal:", treasuryShares);
        assertTrue(treasuryShares > 0, "Fees should be collected before withdrawal");

        console2.log("");
        console2.log("RESULT: Cannot bypass fees - collected before processing");
    }
}
