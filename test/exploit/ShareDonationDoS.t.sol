// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console2} from "forge-std/Test.sol";
import {USDCSavingsVault} from "../../src/USDCSavingsVault.sol";
import {RoleManager} from "../../src/RoleManager.sol";
import {MockUSDC} from "../mocks/MockUSDC.sol";

/**
 * @title ShareDonationDoS
 * @notice Tests verifying Share Donation DoS Attack is PREVENTED
 * @dev V-2 FIX: Direct transfers to vault address are now BLOCKED
 *
 * ORIGINAL VULNERABILITY: An attacker could donate shares to block withdrawals
 * PREVIOUS FIX: Changed escrow check to >= (tolerate donations, recover later)
 * V-2 FIX: Block the root cause - prevent transfers to vault entirely
 *
 * Users must use requestWithdrawal() to escrow shares properly.
 * Direct transfers to vault revert with CannotTransferToVault error.
 */
contract ShareDonationDoS is Test {
    USDCSavingsVault public vault;
    RoleManager public roleManager;
    MockUSDC public usdc;

    address public owner = address(this);
    address public multisig = makeAddr("multisig");
    address public treasury = makeAddr("treasury");
    address public operator = makeAddr("operator");

    address public attacker = makeAddr("attacker");
    address public victim = makeAddr("victim");

    uint256 public constant FEE_RATE = 0.2e18;
    uint256 public constant COOLDOWN = 1 days;

    function setUp() public {
        usdc = new MockUSDC();
        roleManager = new RoleManager(owner);

        vault = new USDCSavingsVault(
            address(usdc),
            address(roleManager),
            multisig,
            treasury,
            FEE_RATE,
            COOLDOWN,
            "USDC Savings Vault Share",
            "svUSDC"
        );
        roleManager.setOperator(operator, true);
        vault.setMaxYieldChangePercent(0);
        vault.setWithdrawalBuffer(type(uint256).max);

        usdc.mint(attacker, 10_000_000e6);
        usdc.mint(victim, 10_000_000e6);

        vm.prank(attacker);
        usdc.approve(address(vault), type(uint256).max);
        vm.prank(victim);
        usdc.approve(address(vault), type(uint256).max);
    }

    /**
     * @notice V-2 FIX: Share donations via transfer() are BLOCKED
     */
    function test_V2_ShareDonation_IsBlocked_Transfer() public {
        console2.log("=== V-2 FIX: SHARE DONATION BLOCKED (transfer) ===");
        console2.log("");

        // Attacker gets some shares
        vm.prank(attacker);
        vault.deposit(1_000_000e6);
        console2.log("Attacker deposited 1M USDC");

        // Attacker tries to donate shares via transfer
        vm.prank(attacker);
        vm.expectRevert(USDCSavingsVault.CannotTransferToVault.selector);
        vault.transfer(address(vault), 1);

        console2.log("Transfer to vault BLOCKED - CannotTransferToVault");
        console2.log("");
        console2.log("=== SHARE DONATION ATTACK PREVENTED ===");
    }

    /**
     * @notice V-2 FIX: Share donations via transferFrom() are BLOCKED
     */
    function test_V2_ShareDonation_IsBlocked_TransferFrom() public {
        console2.log("=== V-2 FIX: SHARE DONATION BLOCKED (transferFrom) ===");
        console2.log("");

        // Attacker gets some shares
        vm.prank(attacker);
        vault.deposit(1_000_000e6);
        console2.log("Attacker deposited 1M USDC");

        // Attacker approves and tries to donate via transferFrom
        vm.prank(attacker);
        vault.approve(victim, type(uint256).max);

        vm.prank(victim);
        vm.expectRevert(USDCSavingsVault.CannotTransferToVault.selector);
        vault.transferFrom(attacker, address(vault), 1);

        console2.log("TransferFrom to vault BLOCKED - CannotTransferToVault");
        console2.log("");
        console2.log("=== SHARE DONATION ATTACK PREVENTED ===");
    }

    /**
     * @notice Verify: Normal withdrawals work without donation interference
     */
    function test_V2_NormalWithdrawals_WorkCorrectly() public {
        console2.log("=== NORMAL WITHDRAWAL FLOW ===");
        console2.log("");

        // Victim deposits and requests withdrawal
        vm.prank(victim);
        uint256 victimShares = vault.deposit(1_000_000e6);
        console2.log("Victim deposited 1M USDC, received shares:", victimShares);

        vm.prank(victim);
        uint256 requestId = vault.requestWithdrawal(victimShares);
        console2.log("Victim requested withdrawal, requestId:", requestId);

        // Verify escrow state is correct
        uint256 vaultBalance = vault.balanceOf(address(vault));
        uint256 pendingShares = vault.pendingWithdrawalShares();
        assertEq(vaultBalance, pendingShares, "Escrow should exactly match pending");
        console2.log("Escrow balance == pending shares (no orphans)");

        // Wait for cooldown
        vm.warp(block.timestamp + COOLDOWN + 1);

        // Fulfill withdrawal
        vm.prank(operator);
        (uint256 processed, uint256 paid) = vault.fulfillWithdrawals(1);

        console2.log("");
        console2.log("Withdrawal processed:", processed);
        console2.log("USDC paid:", paid);
        assertEq(processed, 1, "Should process 1 withdrawal");
        assertGt(paid, 0, "Should pay USDC");

        console2.log("");
        console2.log("=== WITHDRAWAL SUCCESSFUL ===");
    }

    /**
     * @notice Verify: Cancel withdrawal works correctly
     */
    function test_V2_CancelWithdrawal_WorksCorrectly() public {
        console2.log("=== CANCEL WITHDRAWAL FLOW ===");
        console2.log("");

        // Victim deposits and requests withdrawal
        vm.prank(victim);
        uint256 victimShares = vault.deposit(1_000_000e6);
        vm.prank(victim);
        uint256 requestId = vault.requestWithdrawal(victimShares);

        // Victim cancels within window
        vm.prank(victim);
        vault.cancelWithdrawal(requestId);

        uint256 victimBalance = vault.balanceOf(victim);
        console2.log("Victim shares after cancel:", victimBalance);
        assertEq(victimBalance, victimShares, "Victim should get all shares back");

        console2.log("");
        console2.log("=== CANCEL SUCCESSFUL ===");
    }

    /**
     * @notice Verify: Force process withdrawal works correctly
     */
    function test_V2_ForceProcessWithdrawal_WorksCorrectly() public {
        console2.log("=== FORCE PROCESS WITHDRAWAL ===");
        console2.log("");

        // Victim deposits and requests withdrawal
        vm.prank(victim);
        uint256 victimShares = vault.deposit(1_000_000e6);
        vm.prank(victim);
        uint256 requestId = vault.requestWithdrawal(victimShares);

        // Owner force processes (skips cooldown)
        vault.forceProcessWithdrawal(requestId);

        uint256 victimUsdc = usdc.balanceOf(victim);
        console2.log("Victim USDC after force:", victimUsdc);
        assertGt(victimUsdc, 0, "Victim should receive USDC");

        console2.log("");
        console2.log("=== FORCE PROCESS SUCCESSFUL ===");
    }

    /**
     * @notice V-3 FIX: recoverOrphanedShares handles edge case gracefully
     * @dev Even though donations are blocked, this tests the defensive check
     */
    function test_V3_RecoverOrphanedShares_DefensiveCheck() public {
        console2.log("=== V-3 FIX: DEFENSIVE CHECK ===");
        console2.log("");

        // Setup with pending withdrawal (creates escrow)
        vm.prank(victim);
        vault.deposit(1_000_000e6);
        vm.prank(victim);
        vault.requestWithdrawal(500_000e18);

        // No orphaned shares exist
        uint256 vaultBalance = vault.balanceOf(address(vault));
        uint256 pendingShares = vault.pendingWithdrawalShares();
        console2.log("Vault balance:", vaultBalance);
        console2.log("Pending shares:", pendingShares);

        // recoverOrphanedShares should return 0 (nothing to recover)
        uint256 recovered = vault.recoverOrphanedShares();
        assertEq(recovered, 0, "Nothing to recover");
        console2.log("Recovered:", recovered);

        console2.log("");
        console2.log("=== DEFENSIVE CHECK WORKS ===");
    }

    /**
     * @notice Verify: User-to-user transfers still work
     */
    function test_V2_UserToUserTransfers_StillWork() public {
        console2.log("=== USER-TO-USER TRANSFERS ===");
        console2.log("");

        // Attacker and victim get shares
        vm.prank(attacker);
        uint256 attackerShares = vault.deposit(1_000_000e6);

        // Attacker can transfer to victim (not to vault)
        vm.prank(attacker);
        vault.transfer(victim, attackerShares);

        uint256 victimBalance = vault.balanceOf(victim);
        uint256 attackerBalance = vault.balanceOf(attacker);

        console2.log("Victim balance:", victimBalance);
        console2.log("Attacker balance:", attackerBalance);
        assertEq(victimBalance, attackerShares, "Victim should receive shares");
        assertEq(attackerBalance, 0, "Attacker should have 0 shares");

        console2.log("");
        console2.log("=== USER TRANSFERS WORK ===");
    }
}
